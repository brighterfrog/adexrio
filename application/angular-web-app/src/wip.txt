pragma solidity >=0.4.22 <0.6.0;
interface Extension {
    /// @notice blake2b256 computes blake2b-256 checksum for given data.
   

    /// @notice These functions return corresponding block info from genesis to best block.
    function blockID(uint num) external view returns(bytes32);
    function blockTotalScore(uint num) external view returns(uint64);
    function blockTime(uint num) external view returns(uint);
    function blockSigner(uint num) external view returns(address);

    /// @return total supply of VET
    function totalSupply() external view returns(uint256);

    /// @notice These funtions return corresponding current transaction info.
    function txProvedWork() external view returns(uint256);
    function txID() external view returns(bytes32);
    function txBlockRef() external view returns(bytes8);
    function txExpiration() external view returns(uint);

    /// @notice Get the account that pays the TX fee at runtime. 
    function txGasPayer() external view returns(address);
}


contract RollItVetSinglePlayerGame {

    ///Contract Owner Settings
    address owner;
    address payable treasury;
    
    Extension en;
    bool gamePaused;
    GameHouseRules gameHouseRules;
    enum GameStatus{ COMPLETE, AWAITING_GAME_CRITIERA_MET, EXPIRED }
    enum PlayerGameStatus { WIN, LOSE, TIE, PENDING_GAME_COMPLETION }
    uint nextGameId;
    mapping (uint => Game) games;
    

    event GameStartedEvent(uint);
    event PlayerJoinedGameEvent(uint);
    event BeginningDiceRoll(uint);
    event GameCompleted(uint);
        
    struct GameHouseRules {
        uint8 houseCommissionPercent;
        uint minBetSize;
        uint8 minGamePlayers;
    }
    struct GameCreatorSettings {
        uint8 minGamePlayers;
        uint256 expirationDateTime;
    }
    struct Game {
        uint id;
        GameStatus status;
        GameCreatorSettings settings;
        mapping(address => PlayerGameEntry) players;
        address payable[] playerAddresses;
        uint winningPayout;
        uint winningPlayersCount;
        uint totalGameWagers;
    }

    struct PlayerGameEntry {
        uint betsize;
        PlayerGameStatus playerGameStatus;
        uint roll;
        bool inCurrentGame;
    }

    modifier onlyOwner {
        require(
            msg.sender == owner,
            "Only owner can call this function."
        );
        _;
    }
    modifier onlyTreasury {
        require(
            msg.sender == treasury,
            "Only treasury can call this function."
        );
        _;
    }

    modifier gameIsActive {
        require(
            gamePaused == true,
            "Game is currently in the paused state"
            );
		_;
    } 
    
    modifier gameIsValid(uint256 _expirationDateTime, uint8 _minGamePlayers) {  
        require(
            msg.value >= gameHouseRules.minBetSize, 
        "Value is not above the minimum bet size");  
        require(
            block.timestamp < _expirationDateTime, 
        "Expiration should be in the future"); 
        require(
            _minGamePlayers >= gameHouseRules.minGamePlayers, 
        "Game players should be above the house rules setting"); 
		_;
    }
    modifier canJoinExistingGame(uint _gameId) {
        require(
            msg.value >= gameHouseRules.minBetSize,
            "Value is not above the minimum bet size"
            );
        require(
            games[_gameId].players[msg.sender].inCurrentGame,
            "Player is already participating in the current game"
            );
        require(
            games[_gameId].playerAddresses.length < games[_gameId].settings.minGamePlayers,
            "Game is at maximum players"
            );
            _;
    }
    
    /// Create a new contract
    constructor() public {
        owner = msg.sender;
        treasury = msg.sender;
        
        uint8 houseCommissionPercent = 1;
        
        ///equivelent of 20 VET
        uint minBetSize = 20000000000000000000;
        uint8 minGamePlayers = 2;
        
        gameHouseRules = GameHouseRules({
            houseCommissionPercent: houseCommissionPercent,
            minBetSize: minBetSize,
            minGamePlayers: minGamePlayers
        });
        
        nextGameId = 0;
    }
    

    // get a number from [1, top]
    function getRandomNumber(uint top) public returns (uint) { 
        require(top > 1, "top > 1 required");

        address extension_native = 0x0000000000000000000000457874656E73696F6e;
        en = Extension(extension_native);

        uint counter = 5;
        uint256 s;
        for (uint i = 1; i < counter; i++) {
            // uint256 s1 = uint256(en.blockSigner( (block.number - i) ));
            // s = s ^ (s1);
            uint256 s2 = uint256(en.blockID( (block.number - i) ));
            s = s ^ (s2);
        }

        uint result = (s % top) + 1;
        
        return result;
    }
    
    /// mark as payable
    /// not only owner, users need to pay VET
    ///gameIsValid(_betsize, _expirationDateTime, _minGamePlayers)
    ///20000000000000000000 / 1000000000000000000 == 20
    ///1000000000000000000
    
    ///test values
    ///1739964683, 2
    function startGame(uint256 _expirationDateTime, uint8 _minGamePlayers) gameIsValid(_expirationDateTime, _minGamePlayers) public payable {
         nextGameId = getGameId();
        
        ///create game with settings
         games[nextGameId] = Game({
            id: nextGameId,
            status: GameStatus.AWAITING_GAME_CRITIERA_MET,
            settings: GameCreatorSettings({ expirationDateTime: _expirationDateTime, minGamePlayers: _minGamePlayers}),
            playerAddresses: new address payable[](_minGamePlayers),
            winningPayout: 0,
            totalGameWagers: msg.value,
            winningPlayersCount: 0
        });
        
        ///create game entry for player
        games[nextGameId].players[msg.sender] = PlayerGameEntry({
            betsize: msg.value, 
            playerGameStatus: PlayerGameStatus.PENDING_GAME_COMPLETION,
            inCurrentGame: true,
            roll: 0
        });
        
        ///track address in iterable
        games[nextGameId].playerAddresses.push(msg.sender);
        
        emit GameStartedEvent(nextGameId);
    }
    
    function joinExistingGame(uint _gameId) canJoinExistingGame (_gameId) public payable {
        Game storage existingGame = games[_gameId];
        
        existingGame.players[msg.sender] = PlayerGameEntry({
            betsize: msg.value, 
            playerGameStatus: PlayerGameStatus.PENDING_GAME_COMPLETION,
            inCurrentGame: true,
            roll: 0
        });
        existingGame.totalGameWagers += msg.value;
        
        emit PlayerJoinedGameEvent(_gameId);
        
        if(gameMeetsCriteriaToStart(_gameId)) {
            beginDiceRoll(_gameId);
        }
    }
    
    function countPotsizeAndRollPlayerDice(uint _gameId) internal{
        uint highRoll = 0;
        Game storage existingGame = games[_gameId];
        for(uint i=0; i<existingGame.playerAddresses.length; i++) {
            
            uint playerRoll = getRandomNumber(existingGame.playerAddresses.length * 10);
            existingGame.players[existingGame.playerAddresses[i]].roll = playerRoll;
            
            if(playerRoll > highRoll) {
                highRoll = playerRoll;
            }
        }
    }
    function beginDiceRoll(uint _gameId) internal {
        uint highRoll = 0;
        Game storage existingGame = games[_gameId];
        
        emit BeginningDiceRoll(_gameId);
        ///count totalPot
        ///assign player roll
        ///track highest roll
        
        for(uint i=0; i<existingGame.playerAddresses.length; i++) {
            
            uint playerRoll = getRandomNumber(existingGame.playerAddresses.length * 10);
            existingGame.players[existingGame.playerAddresses[i]].roll = playerRoll;
            
            if(playerRoll > highRoll) {
                highRoll = playerRoll;
            }
        }
        
        ///count winners & set status;
        ///deduct from losing accounts
        for(uint i=0; i<existingGame.playerAddresses.length; i++) {
            if (existingGame.players[existingGame.playerAddresses[i]].roll == highRoll) {
               existingGame.winningPlayersCount++;
               existingGame.players[existingGame.playerAddresses[i]].playerGameStatus = PlayerGameStatus.WIN;
            }
        }
    
         ///withold house percent and pay house
         uint houseCommissionWitholdings = existingGame.totalGameWagers * gameHouseRules.houseCommissionPercent / 100;
         treasury.transfer(houseCommissionWitholdings);
         
         ///divide payout by winnerCount to send
         existingGame.winningPayout = existingGame.totalGameWagers - houseCommissionWitholdings;
         
         ///calc individual payout
         uint playerPayout = existingGame.winningPayout / existingGame.winningPlayersCount;
         
         ///loop over winners to payout pot over total winning players
         for(uint i=0; i<existingGame.playerAddresses.length; i++) {
            if (existingGame.players[existingGame.playerAddresses[i]].playerGameStatus == PlayerGameStatus.WIN) {
                existingGame.playerAddresses[i].transfer(playerPayout);
            }
        }
        
        emit GameCompleted(_gameId);
    }
    
    function gameMeetsCriteriaToStart(uint _gameId) internal view returns (bool) {
        Game memory existingGame = games[_gameId];
        return existingGame.playerAddresses.length == existingGame.settings.minGamePlayers;
    }

    function getGameId() internal returns (uint) {
        uint currentGameId = nextGameId;
        nextGameId += 1;
        return currentGameId;
    }
    
    function destroy() onlyOwner public  {
        selfdestruct(msg.sender);
    }

}
