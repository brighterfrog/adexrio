type Feedback @model {
  comment: String!
  commentType: feedbackType!
  status: feedbackStatus!
  wallet: String!
}

enum feedbackStatus {
  pending
  reviewed
  projectItem
}

enum feedbackType {
  general
  enhancement
  bug
  interest
}

type Message @model {
  id: ID!
  message: String!
  wallet: String!
  createdAt: String!
}

type GamesSummary @model @key(fields: ["id"]) {
  id: Int!
  totalCompletedGames: Int!
  totalUniquePlayers: Int!
  totalPayouts: Float!
  highestPayout: Float!
}

type ErrorLog @model {
  id: ID!
  createdAt: String!
  stackTrace: String!
}

enum poolType {
  lottery
  manual
  api  
  custom_builder
}
enum poolStatus {
  awaiting
  completed
  terminated
}
enum PlayerStatus {
  pending_pool_completion
  withdrew
  win
  lose
}

type Player @model 
 { 
  userWallet: UserWallet! @connection
  status: PlayerStatus!
  pool: Pool! @connection(name: "PoolPlayers")    
}

type ApiPoolAttributes @model
 {    
  lockFundsDatetime: AWSDateTime!
  executeWinnerDatetime: AWSDateTime!
  apiUrlForResults: AWSURL!
  verifiedUrlSchema: Boolean!
  poolCreatorPercentFeeToWithold: Int!
  apiWinnerOptionEntries: AWSJSON!
  apiwinnerResult: String! 
  poolApiDefaultSchema: AWSJSON!
  poolApiCustomSchema: AWSJSON
  pool: Pool @connection(name: "ApiPoolAttributes")
}

enum PoolCategory {
  other
  sports
  gaming
  politics
  grudge_match
}

type Pool @model 
{  
  poolId: Int!  
  poolTitle: String!   
  poolCategory: PoolCategory! 
  poolCreator: UserWallet! @connection 
  poolType: poolType! 
  poolStatus: poolStatus!
  poolEntryFee: Int!
  poolTotal: Int!
  poolWinningPayout: Int!  
  allowPlayerLeave: Boolean!
  apiPoolAttributes: ApiPoolAttributes @connection(name: "ApiPoolAttributes")
  requestHash: String!  
  players: [Player] @connection(name: "PoolPlayers")
}

type PoolSuccessfullBlockEventsProcessed @model {
  id: ID!
  lastBlockProcessedForCreatedEvents: Int!
  lastBlockProcessedForCompletedEvents: Int!
  lastBlockProcessedForPlayerJoinedPoolEvents: Int!
  lastBlockProcessedForPlayerLeftPoolEvents: Int!
  lastBlockProcessedForPoolAwaitingExecution: Int!  

  lambdaProcessorDecisionCheckForNextBlocknumber: Int! 
  historicalLastBlockLoadedForEvents: Int! 
}

type PoolSummaries @model {
  id: ID!
  totalCompletedGames: Int!
  totalPlayers: Int!
  totalPayouts: Int!
  highestSingleWinnerPayout: Int!
  highestPoolPayout: Int!
}

type UserWallet @model
{
  id: ID!
  wallet: String!
  nickname: String!
  chatlogo: AWSURL
  brands: Brand @connection
  totalWinnings: Int!
  totalPools: Int!
  totalCompletedPools: Int!
  totalPoolsWon: Int!  
}
type Brand @model
 {
  id: ID!
  wallet: String!
  name: String!
  rating: Int!
  logo: AWSURL  
}

# S3 event ingestion
input CreateIngestionBucketEventInput {
  event: AWSJSON!
}
type IngestionBucketResponse {	
  s3: AWSJSON!
  sqs: AWSJSON!
}
type Mutation {
  createIngestionEvent(input: CreateIngestionBucketEventInput!): IngestionBucketResponse 
    @function(name: "addBlocktickerEventToS3-${env}")
    @function(name: "addBlocktickerEventToSQS-${env}")
}
